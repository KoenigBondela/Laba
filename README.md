Приложение демонстрирует работу с разными консольными меню для ролей `user` и `root`, реализованную через паттерн **Strategy**, а также использование **AspectJ** для логирования основных действий (авторизация, открытие меню, изменение конфигурации, добавление пользователя).

### Стек

- **JDK 21**
- **Maven**
- **AspectJ** (через `aspectj-maven-plugin`)

---

### Постановка задачи

Необходимо реализовать консольное приложение для настроек оборудования. В зависимости от типа авторизации (user/root) пользователю показывается различное меню.

- Для **user**:
  1. Просмотреть настройки оборудования
  2. Просмотреть статистику по оборудованию
  3. Выход

- Для **root**:
  1. Изменить настройки оборудования
  2. Просмотреть статистику по оборудованию
  3. Добавить нового пользователя
  4. Выход

Требование: решить задачу с использованием соответствующего паттерна и AspectJ.

---

### Используемый паттерн и обоснование выбора

В данном решении применён паттерн **Strategy (Стратегия)**.

- **Контекст** – класс `MenuContext`:
  - не знает деталей реализации разных меню;
  - работает всегда через общий интерфейс `MenuStrategy`.

- **Стратегия** – интерфейс `MenuStrategy`:
  - определяет общий контракт `showMenu(Scanner scanner)` для разных вариантов поведения (меню).

- **Конкретные стратегии**:
  - `UserMenuStrategy` – меню для роли `USER`;
  - `RootMenuStrategy` – меню для роли `ROOT`.

**Почему Strategy подходит лучше всего:**

- Меню **зависит от роли пользователя**, но логика выбора меню проста и сводится к подстановке нужной реализации.
- Появляется гибкость:
  - легко добавить новые типы ролей и новые меню, просто реализовав ещё одну стратегию (например, `ReadOnlyMenuStrategy` или `SupportMenuStrategy`);
  - код `Main` и `MenuContext` при этом практически не меняется.
- Разделение ответственности:
  - авторизация (`AuthService`) отвечает только за определение роли;
  - выбор и работа меню – в слое стратегий;
  - бизнес-операции (настройки и статистика) – в сервисах (`EquipmentConfigService`, `EquipmentStatsService`).

Альтернативой мог бы быть паттерн **State (Состояние)**, однако:

- Состояние обычно предполагает, что объект **сам меняет своё состояние** в процессе работы (переходит между состояниями).
- В нашей задаче «состояние» (роль) выбирается один раз при авторизации и далее **не меняется** в рамках сессии.
- Поэтому **Strategy** более естественен: мы однажды выбираем конкретную стратегию (меню) в зависимости от роли и далее просто её используем.