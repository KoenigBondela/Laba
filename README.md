## Консольное приложение настроек оборудования (Java + Maven + AspectJ)

Приложение демонстрирует работу с разными консольными меню для ролей `user` и `root`, реализованную через паттерн **Strategy**, а также использование **AspectJ** для логирования основных действий (авторизация, открытие меню, изменение конфигурации, добавление пользователя).

### Стек

- **Java 17**
- **Maven**
- **AspectJ** (через `aspectj-maven-plugin`)

---

### Постановка задачи

Необходимо реализовать консольное приложение для настроек оборудования. В зависимости от типа авторизации (user/root) пользователю показывается различное меню.

- Для **user**:
  1. Просмотреть настройки оборудования
  2. Просмотреть статистику по оборудованию
  3. Выход

- Для **root**:
  1. Изменить настройки оборудования
  2. Просмотреть статистику по оборудованию
  3. Добавить нового пользователя
  4. Выход

Требование: решить задачу с использованием соответствующего паттерна и AspectJ.

---

### Структура проекта

Корень:

- **`pom.xml`** – Maven-конфигурация, подключает:
  - `aspectjrt` – рантайм AspectJ
  - `aspectj-maven-plugin` – компиляция и weave аспектов
  - `exec-maven-plugin` – запуск `main` класса
- **`README.md`** – данное описание

Код:

- **`src/main/java/org/example/app/Main.java`**
  - Точка входа.
  - Запрашивает логин/пароль.
  - Через `AuthService` получает роль (`USER` или `ROOT`).
  - В зависимости от роли выбирает соответствующую стратегию меню:
    - `UserMenuStrategy`
    - `RootMenuStrategy`
  - Передаёт выбранную стратегию в `MenuContext` и запускает цикл работы меню.

- **`src/main/java/org/example/auth/Role.java`**
  - Enum с ролями: `USER`, `ROOT`.

- **`src/main/java/org/example/auth/AuthService.java`**
  - Простейшая имитация хранилища пользователей (в памяти).
  - Предустановленные пользователи:
    - `user / user123` → роль `USER`
    - `root / root123` → роль `ROOT`
  - Метод `authenticate()`:
    - считывает логин/пароль с консоли;
    - проверяет пользователя и пароль;
    - возвращает роль или `null` при неуспехе.
  - Метод `addUser()`:
    - добавляет нового пользователя с ролью `USER`.

- **`src/main/java/org/example/menu/MenuStrategy.java`**
  - Интерфейс паттерна **Strategy**.
  - Определяет метод `showMenu(Scanner scanner)` – один и тот же контракт для всех меню.

- **`src/main/java/org/example/menu/MenuContext.java`**
  - Контекст паттерна **Strategy**.
  - Поле `MenuStrategy menuStrategy`.
  - Методы:
    - `setMenuStrategy(MenuStrategy menuStrategy)` – установка конкретной стратегии (конкретного меню).
    - `run(Scanner scanner)` – запуск меню через текущую стратегию.

- **`src/main/java/org/example/menu/UserMenuStrategy.java`**
  - Конкретная стратегия для роли `USER`.
  - Показывает меню:
    1. Просмотреть настройки оборудования (`EquipmentConfigService.viewConfig()`)
    2. Просмотреть статистику (`EquipmentStatsService.showStats()`)
    3. Выход
  - Цикл опрашивает пользователя до выбора пункта «Выход».

- **`src/main/java/org/example/menu/RootMenuStrategy.java`**
  - Конкретная стратегия для роли `ROOT`.
  - Показывает меню:
    1. Изменить настройки оборудования (считывается строка новой конфигурации и вызывается `EquipmentConfigService.changeConfig()`)
    2. Просмотреть статистику (`EquipmentStatsService.showStats()`)
    3. Добавить нового пользователя (`AuthService.addUser()`)
    4. Выход
  - Аналогично, реализован цикл опроса до выхода.

- **`src/main/java/org/example/services/EquipmentConfigService.java`**
  - Сервис для работы с настройками оборудования.
  - Поле `currentConfig` – простая строка-конфигурация.
  - `viewConfig()` – выводит текущие настройки.
  - `changeConfig(String newConfig)` – изменяет конфигурацию и выводит сообщение об успешном применении.

- **`src/main/java/org/example/services/EquipmentStatsService.java`**
  - Сервис для отображения статистики оборудования.
  - `showStats()` – выводит простую «фиктивную» статистику (CPU, память, трафик).

- **`src/main/java/org/example/aspects/LoggingAspect.java`**
  - Класс с аннотацией `@Aspect` – аспект для логирования:
    - Логирует начало и результат авторизации:
      - `@Before` и `@AfterReturning` для `AuthService.authenticate(..)`
    - Логирует открытие меню:
      - `@Before` на `execution(* org.example.menu.*MenuStrategy.showMenu(..))`
    - Логирует изменение конфигурации:
      - `@Before` на `EquipmentConfigService.changeConfig(..)`
    - Логирует добавление нового пользователя:
      - `@Before` на `AuthService.addUser(..)`

---

### Как работает приложение

1. Пользователь запускает приложение (см. раздел ниже «Сборка и запуск»).
2. В консоли отображается приветствие и запрос логина/пароля.
3. `AuthService`:
   - проверяет логин и пароль;
   - при успехе возвращает роль (`USER` или `ROOT`), при неуспехе – выводит сообщение и приложение завершается.
4. В `Main` по роли выбирается стратегия:
   - для `USER` → `UserMenuStrategy`;
   - для `ROOT` → `RootMenuStrategy`.
5. `MenuContext` получает стратегию и вызывает `showMenu(scanner)`:
   - для `USER`:
     - пользователь может только просматривать настройки и статистику;
   - для `ROOT`:
     - доступно изменение настроек, просмотр статистики и добавление новых пользователей.
6. Все важные действия (авторизация, открытие меню, изменение конфигурации, добавление пользователя) логируются аспектом `LoggingAspect` и выводятся в консоль с префиксом `[LOG]`.

---

### Сборка и запуск

Требуется установленный **Maven** и **JDK 17** (или совместимая).

Из корня проекта:

1. **Сборка**:

   ```bash
   mvn clean package
   ```

2. **Запуск через exec-maven-plugin**:

   ```bash
   mvn exec:java
   ```

   Либо указав main-класс явно:

   ```bash
   mvn exec:java -Dexec.mainClass="org.example.app.Main"
   ```

При запуске в консоли появятся запросы логина и пароля. Для проверки можно использовать:

- Логин: `user`, пароль: `user123` – получите меню пользователя.
- Логин: `root`, пароль: `root123` – получите меню администратора.

---

### Используемый паттерн и обоснование выбора

В данном решении применён паттерн **Strategy (Стратегия)**.

- **Контекст** – класс `MenuContext`:
  - не знает деталей реализации разных меню;
  - работает всегда через общий интерфейс `MenuStrategy`.

- **Стратегия** – интерфейс `MenuStrategy`:
  - определяет общий контракт `showMenu(Scanner scanner)` для разных вариантов поведения (меню).

- **Конкретные стратегии**:
  - `UserMenuStrategy` – меню для роли `USER`;
  - `RootMenuStrategy` – меню для роли `ROOT`.

**Почему Strategy подходит лучше всего:**

- Меню **зависит от роли пользователя**, но логика выбора меню проста и сводится к подстановке нужной реализации.
- Появляется гибкость:
  - легко добавить новые типы ролей и новые меню, просто реализовав ещё одну стратегию (например, `ReadOnlyMenuStrategy` или `SupportMenuStrategy`);
  - код `Main` и `MenuContext` при этом практически не меняется.
- Разделение ответственности:
  - авторизация (`AuthService`) отвечает только за определение роли;
  - выбор и работа меню – в слое стратегий;
  - бизнес-операции (настройки и статистика) – в сервисах (`EquipmentConfigService`, `EquipmentStatsService`).

Альтернативой мог бы быть паттерн **State (Состояние)**, однако:

- Состояние обычно предполагает, что объект **сам меняет своё состояние** в процессе работы (переходит между состояниями).
- В нашей задаче «состояние» (роль) выбирается один раз при авторизации и далее **не меняется** в рамках сессии.
- Поэтому **Strategy** более естественен: мы однажды выбираем конкретную стратегию (меню) в зависимости от роли и далее просто её используем.

---

### Использование AspectJ

AspectJ здесь применяется для реализации **сквозной функциональности** (cross-cutting concern) – логирования:

- Вместо того чтобы размазывать `System.out.println("[LOG] ...")` по коду авторизации, меню и сервисов, логика собрана в одном месте – `LoggingAspect`.
- Точки внедрения (pointcuts) описаны декларативно:
  - `execution(* org.example.auth.AuthService.authenticate(..))` – логирование попытки и результата авторизации;
  - `execution(* org.example.menu.*MenuStrategy.showMenu(..))` – логирование открытия меню;
  - `execution(* org.example.services.EquipmentConfigService.changeConfig(..))` – логирование изменения настроек;
  - `execution(* org.example.auth.AuthService.addUser(..))` – логирование добавления пользователя.

Таким образом:

- Основной бизнес-код (меню, сервисы) остаётся чистым и не «зашумлён» логированием.
- Сквозная функциональность удобно включается и настраивается отдельным аспектом.

---

### Как расширять решение

- **Новые роли и меню**:
  - добавить новый enum-элемент в `Role`;
  - реализовать новый класс, реализующий `MenuStrategy`;
  - выбрать его в `Main` (в `switch` по роли).

- **Новая сквозная функциональность**:
  - добавить новый аспект (например, для измерения времени выполнения операций или для более сложной авторизации);
  - описать нужные pointcut’ы и advice’ы в AspectJ-аннотациях.


